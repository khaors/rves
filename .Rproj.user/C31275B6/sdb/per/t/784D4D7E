{
    "collab_server" : "",
    "contents" : "#' @section calibration functions:\n#'\n#' This section includes all the functions required for the estimation of the thicknesses and real resitivities from the VES data. The functions included here are:\n#'\n#' rss_resisitivity, log_rss_resistivity, mnad_resistivity, log_mnad_resistivity, mxad_resistivity, log_mxad_resistivity, calibrate\n#'\n#' @docType package\n#' @name rves\nNULL\n#' @title\n#' rss_resistivity\n#' @description\n#' Function to calculate the residual sum of squares between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the residual sum of squares\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nrss_resistivity <-function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  print(length(apprho_calculated$appres))\n  res <- sqrt(mean((apprho_measured-apprho_calculated$appres)^2))\n  return(res)\n}\n#' @title\n#' log_rss_resistivity\n#' @description\n#' Function to calculate the log of the residual sum of squares between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the log of the residual sum of squares\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nlog_rss_resistivity <- function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  res <- sqrt(mean((log10(apprho_measured)-log10(apprho_calculated$appres))^2))\n  return(res)\n}\n#' @title\n#' mnad_resistivity\n#' @description\n#' Function to calculate the mean absolute deviation between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the mean absolute deviation\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nmnad_resistivity <- function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  res <- mean(abs((apprho_measured-apprho_calculated$appres)))\n  return(res)\n}\n#' @title\n#' log_mnad_resistivity\n#' @description\n#' Function to calculate the log of the mean absolute deviation between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the log of the mean absolute deviation\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nlog_mnad_resistivity <- function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  res <- mean(abs((log10(apprho_measured)-log10(apprho_calculated$appres))))\n}\n#' @title\n#' mxad_resistivity\n#' @description\n#' Function to calculate the maximum absolute deviation between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the maximum absolute deviation\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nmxad_resistivity <- function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  res <- max(abs((apprho_measured-apprho_calculated$appres)))\n  return(res)\n}\n#' @title\n#' log_mxad_resistivity\n#' @description\n#' Function to calculate the log of the maximum absolute deviation between the measured and calculated apparent resistivity.\n#' @param par A numeric vector with the values of the real resisitivity and the layer thickness\n#' @param filter A numeric vector with the filter coefficients for a schlumberger array\n#' @param apprho_measured A numeric vector with the values of the measured apparent resistivity\n#' @return\n#' A numeric value with the log of the maximum absolute deviation\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @family calibration functions\n#' @export\nlog_mxad_resistivity <- function(par, filter, apprho_measured){\n  npar <- length(par)/2\n  rho <- par[1:npar]\n  thick <- par[(npar+1):length(par)]\n  apprho_calculated <- apparent_resistivities(rho, thick, filter)\n  res <- max(abs((log10(apprho_measured)-log10(apprho_calculated$appres))))\n  return(res)\n}\n#' @title\n#' calibrate\n#' @description\n#' Function to estimate the resistivities\n#' @param ves A VES object\n#' @param opt.method A character string specifying the optimization method used to estimate the real resisitivity\n#' @param obj.fn Objective function used in the parameter estimation\n#' @param par0 A numeric vector with the Initial solution\n#' @param lower A numeric vector of length equal to the number of layers with the min values of the parameter space\n#' @param upper A numeric vector of length equal to the number of layers with the max values of the parameter space\n#' @param control.par A list with the parameters of the optimization algorithm\n#' @return\n#' This function returns a list with the following entries:\n#' \\itemize{\n#' \\item a\n#' \\item b\n#' \\item c\n#' }\n#' @importFrom stats optim\n#' @importFrom GenSA GenSA\n#' @importFrom GA ga\n#' @author\n#' Oscar Garcia-Cabrejo \\email{khaors@gmail.com}\n#' @export\ncalibrate <- function(ves, opt.method = c(\"L-BFGS-B\", \"SA\", \"GA\"),\n                      obj.fn = c('rss', 'mnad', 'mxad', 'log_rss', 'log_mnad', 'log_mxad'),\n                      par0 = par0, lower = lower, upper = upper, control.par = NULL){\n  if(class(ves) != \"ves\"){\n    stop('ERROR: A ves object is required as input')\n  }\n  res <- NULL\n  if(opt.method == \"L-BFGS-B\"){\n    res <- optim(par0, rss_resistivity, filter = as.matrix(rves::filt$V1),\n                 apprho_measured = ves$appres,\n                 method = 'L-BFGS-B', lower = lower, upper = upper)\n  }\n  else if(opt.method == \"SA\"){\n    if(is.null(control.par)){\n      control.par <- list(maxit = 100, threshold.stop = 0.1, nb.stop.improvement = 50,\n                          smooth = FALSE, simple.function = TRUE, verbose = TRUE)\n    }\n    res <- GenSA(par0, rss_resistivity, lower = lower, upper = upper,\n                     control = control.par, filter = as.matrix(rves::filt$V1),\n                     apprho_measured = ves$appres)\n  }\n  else if(opt.method == \"GA\"){\n    if(is.null(control.par)){\n      control.par <- list(method = \"L-BFGS-B\", poptim = 0.05, pressel = 0.5,\n                          control = list(fnscale = -1, maxit = 100))\n    }\n    res <- ga(type = \"real-valued\",\n                 fitness =  function(par, filter, apprho_measured) {-rss_resistivity(par, filter, apprho_measured)},\n                 filter = as.matrix(rves::filt$V1), apprho_measured = ves$appres,\n                 min = lower, max = upper,\n                 popSize = 300, maxiter = 500, pcrossover = 0.85, pmutation = .2,\n                 run = 50, maxFitness = -.05,\n                 optim = TRUE, optimArgs = control.par)\n\n  }\n  return(res)\n}\n",
    "created" : 1493135402254.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4205834112",
    "id" : "784D4D7E",
    "lastKnownWriteTime" : 1507088421,
    "last_content_update" : 1507088421829,
    "path" : "~/Oscar/Rfiles/rves/R/calibration.R",
    "project_path" : "R/calibration.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}