<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VES Smoothing using the rves package • rves</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/1.7.1/clipboard.min.js" integrity="sha384-cV+rhyOuRHc9Ub/91rihWcGmMmCXDeksTtCihMupQHSsi8GIIRDG0ThDc3HGQFJ3" crossorigin="anonymous"></script><!-- sticky kit --><script src="https://cdnjs.cloudflare.com/ajax/libs/sticky-kit/1.1.3/sticky-kit.min.js" integrity="sha256-c4Rlo1ZozqTPE2RLuvbusY3+SU1pQaJC0TjuhygMipw=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="VES Smoothing using the rves package">
<meta property="og:description" content="">
<meta name="twitter:card" content="summary">
<!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rves</a>
        <span class="label label-default" data-toggle="tooltip" data-placement="bottom" title="Released package">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rves-modelselection.html">Stepwise Estimation of VES parameters and Model selection using the rves package</a>
    </li>
    <li>
      <a href="../articles/rves-smoothing.html">VES Smoothing using the rves package</a>
    </li>
    <li>
      <a href="../articles/rves-transformation.html">Resistivity-Depth Transformations using the rves package</a>
    </li>
    <li>
      <a href="../articles/rves-tutorial.html">RVES Tutorial: Vertical Electrical Sounding interpretation using R</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>VES Smoothing using the rves package</h1>
                        <h4 class="author">Oscar Garcia-Cabrejo</h4>
            
            <h4 class="date">2018-07-16</h4>
      
      
      <div class="hidden name"><code>rves-smoothing.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Vertical Electrical Sounding (VES) is one of the oldest resistivity methods and its the main geophysical method used in groundwater exploration due to its cost and investigation depth. In a VES, measurements of apparent resistivity are taked for different values of node spacing. As in any measurement of a physical property, the values of apparent resistivity sometimes include some degree of noise which is an obstacle for a proper parameter estimation (thicknesses and real resistivities). Given the ubiquity of noise in measurements of the apparent resistivities, there are no predefined methodologies to remove the noise ocurring in VES. In the rves package, the noise removal problem is solved using smoothing techniques where the main goal is to extract a smooth curve from a set of measurements. There are several smoothing techniques that can be used to filter or smooth the apparent resistivity measurements, but they do not have a widespread use. Therefore in this package three smoothing techniques are included to help in the pre-processing of the VES measurements and improve the inversion process. The three smoothing techniques are smoothing spline, kernel regression and wavelet thresholding.</p>
</div>
<div id="basic-concepts" class="section level1">
<h1 class="hasAnchor">
<a href="#basic-concepts" class="anchor"></a>Basic Concepts</h1>
<div id="smoothing-via-splines" class="section level2">
<h2 class="hasAnchor">
<a href="#smoothing-via-splines" class="anchor"></a>Smoothing via splines</h2>
<p>In this section a basic introduction to smoothing using spline is given. More details about this procedure can be found in <span class="citation">Green and Silverman (1994)</span>. Let <span class="math inline">\(\{x_{i},\rho_{\text{app},i}:i=1,\ldots.n\}\)</span> be a set of measurements of electrode spacing <span class="math inline">\(x\)</span> and apparent resistivity <span class="math inline">\(\rho_{\text{app}}\)</span> in what is called a VES (Vertical Electrical Sounding). It is assumed that the measurements of apparent resistivity are described by a model <span class="math inline">\(\rho_{\text{app},i}=\hat{\rho}_{\text{app},i} + \epsilon_{i}\)</span> where <span class="math inline">\(\epsilon_{i}\)</span> are a set of independent random variables with zero mean and constant variance, and <span class="math inline">\(\hat{\rho}_{\text{app},i}\)</span> is a cubic smoothing spline that approximates the measurements <span class="math inline">\(\rho_{\text{app},i}\)</span>. This cubic spline is a third order polynomial defined as: <span class="math display">\[
\hat{\rho}_{\text{app},i}(x) = a_{i}(x-x_{i})^{3}+b_{i}(x-x_{i})^{2} + c_{i}(x-x_{i}) + d_{i}
\]</span> where <span class="math inline">\(a_{i},b_{i},c_{i}\)</span> and <span class="math inline">\(d_{i}\)</span> are fixed coefficients that can be estimated from the measured data. The coefficients of the function <span class="math inline">\(\hat{\rho}_{\text{app},i}\)</span> can be estimated as the minimum of: <span class="math display">\[
\sum\limits_{i=1}^{n}[\rho_{\text{app},i}-\hat{\rho}_{\text{app},i}]^{2} + \lambda \int \hat{\rho}_{\text{app}}^{''}(x)^{2}dx
\]</span> where <span class="math inline">\(\lambda\)</span> is the smoothing parameter, and the function <span class="math inline">\(\hat{\rho}_{\text{app},i}\)</span> is assumed as continuous with at least second order derivative. The previous equation aims at defining a function that approximates the measured values (first term) while minimizing the roughness of the estimated function (second term). This tradeoff is controlled by the <span class="math inline">\(\lambda\)</span> parameter that is called the smoothing parameter. If <span class="math inline">\(\lambda \rightarrow 0\)</span> then there is no smoothing and the spline interpolation is obtained. If <span class="math inline">\(\lambda \rightarrow \infty\)</span> then all the weight is given to the roughness penalty and a least-squares estimate is obtained.</p>
</div>
<div id="smoothing-via-kernel-regression" class="section level2">
<h2 class="hasAnchor">
<a href="#smoothing-via-kernel-regression" class="anchor"></a>Smoothing via Kernel Regression</h2>
<p>Another approach to smooth the VES data is to use local polynomial regressions. This is a well known statistical procedure and more information can be found in <span class="citation">Kloke and McKean (2015)</span>. In this approach, the function that approximates the apparent resistivity measurements is a polynomial of order <span class="math inline">\(p\)</span> defined as: <span class="math display">\[
\hat{\rho}_{\text{app},i}(x) = a_{0} + a_{1}(x-x_{i})+\frac{a_{2}}{2!}(x-x_{i})^{2} + \ldots + \frac{a_{p}}{p!}(x-x_{i})^{p}
\]</span> where the <span class="math inline">\((a_{i},i=0,\ldots,p)\)</span> are fixed coefficients that are estimated by minimizing: <span class="math display">\[
\sum_{i=1}^{n}w_{i}(x)[\rho_{\text{app}}(x_{i})-\hat{\rho}_{\text{app},i}(x)]^{2}
\]</span></p>
<p>The coefficientes <span class="math inline">\(a_{i}\)</span> can be estimated using weighted linear least-squares: <span class="math display">\[
\boldsymbol{a}=(\boldsymbol{X}_{X}^{T} \boldsymbol{W}_{X} \boldsymbol{X}_{X})^{-1} \boldsymbol{X}_{X}^{T}\boldsymbol{W}_{X}\boldsymbol{Y}
\]</span> where the matrix <span class="math inline">\(\boldsymbol{X}_{X}\)</span> is defined as: <span class="math display">\[
\boldsymbol{X}_{X}=\left[
\begin{array}{cccc}
1&amp; (x-x_{1})&amp; \cdots&amp; \frac{(x-x_{1})^{p}}{p!}\\
1&amp; (x-x_{2})&amp; \cdots&amp; \frac{(x-x_{2})^{p}}{p!}\\
\vdots&amp; \vdots&amp; \cdots&amp; \vdots\\
1&amp; (x-x_{n})&amp; \cdots&amp; \frac{(x-x_{n})^{p}}{p!}\\
\end{array}
\right]
\]</span> and the weight matrix is given by: <span class="math display">\[
\boldsymbol{W}_{X}=\left[
\begin{array}{cccc}
w(x_{1})&amp; 0&amp; \cdots &amp; 0 \\
0&amp; w(x_{2})&amp; \cdots &amp; 0 \\
\vdots&amp; \vdots&amp; \vdots&amp; \vdots \\
0&amp; 0&amp; \cdots &amp; w(x_{n})
\end{array}
\right]
\]</span></p>
</div>
<div id="smoothing-via-wavelet-shrinkage" class="section level2">
<h2 class="hasAnchor">
<a href="#smoothing-via-wavelet-shrinkage" class="anchor"></a>Smoothing via Wavelet Shrinkage</h2>
<p>Another approach to smoothing comes from the signal processing community using the wavelet transform as proposed by <span class="citation">(Taswell 2000)</span>. Let <span class="math inline">\(\{x_{i},\rho_{\text{app},i}:i=1,\ldots.n\}\)</span> be a set of measurements of a VES ( electrode spacing <span class="math inline">\(x\)</span> and apparent resistivity <span class="math inline">\(\rho_{\text{app}}\)</span>). Again it is assumed that the measurements of the apparent resistivity <span class="math inline">\(\rho_{\text{app},i}^{m}\)</span> are given by: <span class="math display">\[
\rho_{\text{app},i}^{m}(x) = \hat{\rho}_{\text{app},i}(x) + \epsilon(x)  
\]</span> where <span class="math inline">\(\hat{\rho}_{\text{app},i}(x)\)</span> are the true values of the apparent resistivity and <span class="math inline">\(\epsilon(x)\)</span> is a noise component that needs to be filtered. Let <span class="math inline">\(W[\cdot]\)</span> and <span class="math inline">\(W^{-1}[\cdot]\)</span> be the forward and inverse wavelet tranform operators, and <span class="math inline">\(D[\cdot,\lambda]\)</span> the denoising operator defined in terms of the <span class="math inline">\(\lambda\)</span> parameter. The smoothing procedure using wavelet shrinkage has three steps:</p>
<ol style="list-style-type: decimal">
<li>Calculate the wavelet transform of the measured apparent resistivity curve: <span class="math display">\[
Y = W[\rho_{\text{app},i}^{m}(x)]
\]</span>
</li>
<li>Apply the denoising operator to the wavelet transform of the measured resistivity: <span class="math display">\[
Z=D[Y,\lambda]
\]</span>
</li>
<li>Calculate the inverse wavelet transform of the denoised wavelet transform: <span class="math display">\[
\hat{\rho}_{\text{app},i}(x)= W^{-1}[Z]
\]</span> As seen in the previous equations, the key of this smoothing technique is the definition of the <span class="math inline">\(\lambda\)</span> parameter called <em>shinkring parameter</em>. As its name suggets, the role of <span class="math inline">\(\lambda\)</span> is to shrink the magnitude of the wavelet transform of a signal <span class="math inline">\(U\)</span> using the following rule:</li>
</ol>
<p><span class="math display">\[
D[U,\lambda]=\text{sgn}{(U)} \max{(0,|U|-\lambda)}
\]</span></p>
<p>The action of this operator is to nullify the values of <span class="math inline">\(U\)</span> for which <span class="math inline">\(|U| &lt; \lambda\)</span>, and reduce the values of <span class="math inline">\(U\)</span> to <span class="math inline">\(|U|-\lambda\)</span> in the case that <span class="math inline">\(|U| &gt; \lambda\)</span>. The small values of <span class="math inline">\(U\)</span> are associated with the high frequency variations in the signals, in other words, this variations are called noise. A similar approach has been used by <span class="citation">(Raj et al. 2016)</span> to denoise VES curves.</p>
</div>
</div>
<div id="example" class="section level1">
<h1 class="hasAnchor">
<a href="#example" class="anchor"></a>Example</h1>
<div id="ves-1" class="section level2">
<h2 class="hasAnchor">
<a href="#ves-1" class="anchor"></a>VES 1</h2>
<p>The first step in the interpretation of a VES is to load the <strong>rves</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rves)</code></pre></div>
<p>For this example, the VES ves_data1 included in the package is used to test the different functions included in <strong>rves</strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(<span class="st">"ves_data1"</span>)</code></pre></div>
<p>The electrode spacing and the apparent resistivity values are defined:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ab2 &lt;-<span class="st"> </span>ves_data1<span class="op">$</span>ab2
apprho &lt;-<span class="st"> </span>ves_data1<span class="op">$</span>apprho</code></pre></div>
<p>and these are used to define the VES object inside R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1a &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ves.html">ves</a></span>(<span class="dt">id=</span> <span class="st">"VES1"</span>, <span class="dt">ab2 =</span> ab2, <span class="dt">apprho =</span> apprho)</code></pre></div>
<p>The plot of the VES used as example can be seen in the following plot:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p1 &lt;-<span class="st"> </span><span class="kw">plot</span>(sev1a, <span class="dt">type =</span> <span class="st">"ves"</span>)</code></pre></div>
<div id="smoothing-via-splines-1" class="section level3">
<h3 class="hasAnchor">
<a href="#smoothing-via-splines-1" class="anchor"></a>Smoothing via splines</h3>
<p>The smoothing of the VES1 using smoothing splines is achieved using the <em>smoothing_ves</em> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.ss &lt;-<span class="st"> </span><span class="kw"><a href="../reference/smoothing_ves.html">smoothing_ves</a></span>(sev1a, <span class="dt">method =</span> <span class="st">"smooth.spline"</span>)</code></pre></div>
<p>Now the results of the smoothing procedure are extracted and assigned to a data.frame:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ab2.def &lt;-<span class="st"> </span><span class="kw">rep</span>(res.ss<span class="op">$</span>ab2, <span class="dv">2</span>)
apprho.def &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'numeric'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
apprho.def[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span>res.ss<span class="op">$</span>apprho
<span class="kw">print</span>(<span class="kw">length</span>(sev1a<span class="op">$</span>appres))
<span class="co">#&gt; [1] 18</span>
apprho.def[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span>sev1a<span class="op">$</span>appres
meas.type &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'character'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
meas.type[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"smooth.spline"</span>, <span class="dv">18</span>)
meas.type[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"raw"</span>, <span class="dv">18</span>)
res.ss.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ab2 =</span> ab2.def, <span class="dt">apprho =</span> apprho.def, 
                        <span class="dt">type =</span> <span class="kw">as.factor</span>(meas.type))</code></pre></div>
<p>A comparison of the measured and smoothed apparent resistivity values are seed in the following figure, where it is evident that there are small differences between the resistivity values. The smoothing procedure using splines corrects the values at intermediate and large spacings.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p.ss &lt;-<span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">x =</span> ab2, <span class="dt">y =</span> apprho, <span class="dt">color =</span> type), 
                              <span class="dt">data =</span> res.ss.df) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_y_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">'Comparison'</span>) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">theme_bw</span>()
<span class="kw">print</span>(p.ss)  </code></pre></div>
<p><img src="rves-smoothing_files/figure-html/plot_smoothspline-1.png" width="576" style="display: block; margin: auto;"> Now, the smoothed resistivity values are used to define a new ves object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1ss &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ves.html">ves</a></span>(<span class="dt">id =</span> <span class="st">"Sounding 1-Smoothing Spline"</span>, <span class="dt">ab2 =</span> res.ss<span class="op">$</span>ab2, 
              <span class="dt">apprho =</span> res.ss<span class="op">$</span>apprho)</code></pre></div>
<p>The initial solution for the calibration procedure are defined as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rho &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">40</span>,<span class="dv">70</span>,<span class="dv">30</span>, <span class="dv">20</span>)
thick &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">2</span>,<span class="dv">10</span>,<span class="dv">50</span>,<span class="dv">500</span>)
par0 &lt;-<span class="st"> </span><span class="kw">c</span>(rho, thick)</code></pre></div>
<p>and the true resistivities and layer thicknesses are estimated using the conventional nonlinear least-squares approach:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.ss.nls &lt;-<span class="st"> </span><span class="kw"><a href="../reference/calibrate_nls.html">calibrate_nls</a></span>(sev1ss, par0, <span class="dt">iterations =</span> <span class="dv">10</span>, <span class="dt">ireport =</span> <span class="dv">5</span>)
<span class="co">#&gt; iteration, RSS, Rel Error =  0 0.002201384 3.110148 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  5 0.0003970715 1.267168 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  9 0.0002212703 0.9438456</span></code></pre></div>
<p>The results of the calibration are assigned to the ves object</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1ss<span class="op">$</span>rhopar &lt;-<span class="st"> </span>res.ss.nls<span class="op">$</span>rho
sev1ss<span class="op">$</span>thickpar &lt;-<span class="st"> </span>res.ss.nls<span class="op">$</span>thickness
sev1ss<span class="op">$</span>interpreted &lt;-<span class="st"> </span><span class="ot">TRUE</span></code></pre></div>
<p>and the results are plotted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p3 &lt;-<span class="st"> </span><span class="kw">plot</span>(sev1ss, <span class="dt">type =</span> <span class="st">"ves"</span>)
<span class="kw">print</span>(p3)</code></pre></div>
<p><img src="rves-smoothing_files/figure-html/plot_sevss-1.png" width="576" style="display: block; margin: auto;"> In this case the change in the shape of the ves curve is not significative, but the effect of the filtering is seen in the reduction of the RMS obtained during calibration that changed from <span class="math inline">\(1.35\)</span> (no smoothing) to <span class="math inline">\(0.81\)</span> (smoothing.spline). The number of layers of the inverted model did not change but there are small variations in the layer resistivities.</p>
</div>
<div id="kernel-regression" class="section level3">
<h3 class="hasAnchor">
<a href="#kernel-regression" class="anchor"></a>Kernel Regression</h3>
<p>Now, let’s try kernel regression. This procedure can be applied to the original ves object using the <em>smoothing_ves</em> function with the <em>kernel.regression</em> option and the corresponding bandwidth:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.kr &lt;-<span class="st"> </span><span class="kw"><a href="../reference/smoothing_ves.html">smoothing_ves</a></span>(sev1a, <span class="dt">method =</span> <span class="st">"kernel.regression"</span>, <span class="dt">bw =</span> <span class="fl">0.5</span>)</code></pre></div>
<p>For effects of the ves smoothing it is recommended to try different values of bw in the interval from <span class="math inline">\(0.1\)</span> to <span class="math inline">\(0.7\)</span>.</p>
<p>Once the results are obtained, a data.frame is created to compare the effect of the smoothing:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ab2.def &lt;-<span class="st"> </span><span class="kw">rep</span>(res.kr<span class="op">$</span>ab2, <span class="dv">2</span>)
apprho.def &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'numeric'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
apprho.def[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span>res.kr<span class="op">$</span>apprho
apprho.def[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span>sev1a<span class="op">$</span>appres
meas.type &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'character'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
meas.type[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"kernel.regression"</span>, <span class="dv">18</span>)
meas.type[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"raw"</span>, <span class="dv">18</span>)
res.kr.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ab2 =</span> ab2.def, <span class="dt">apprho =</span> apprho.def, 
                        <span class="dt">type =</span> <span class="kw">as.factor</span>(meas.type))</code></pre></div>
<p>and the results are plotted:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p.kr &lt;-<span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">x =</span> ab2, <span class="dt">y =</span> apprho, <span class="dt">color =</span> type), 
                              <span class="dt">data =</span> res.kr.df) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_y_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">'Comparison'</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()
<span class="kw">print</span>(p.kr)  </code></pre></div>
<p><img src="rves-smoothing_files/figure-html/plot_kernelregression-1.png" width="672" style="display: block; margin: auto;"> As seen in the smooth.spline case, the effect of the filtering is visible for intermediate to large spacings. With the filtered values, a new ves object is defined:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1kr &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ves.html">ves</a></span>(<span class="dt">id =</span> <span class="st">"Sounding 1-Kernel Regression"</span>, <span class="dt">ab2 =</span> res.kr<span class="op">$</span>ab2, 
              <span class="dt">apprho =</span> res.kr<span class="op">$</span>apprho)</code></pre></div>
<p>and the estimates of the real resistivities and thicknesses is obtained:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.kr.nls &lt;-<span class="st"> </span><span class="kw"><a href="../reference/calibrate_nls.html">calibrate_nls</a></span>(sev1kr, par0, <span class="dt">iterations =</span> <span class="dv">10</span>, <span class="dt">ireport =</span> <span class="dv">5</span>)
<span class="co">#&gt; iteration, RSS, Rel Error =  0 0.002041967 3.017298 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  5 0.0002895334 1.084667 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  9 0.0001384567 0.7404027</span></code></pre></div>
<p>The calibration results are assigned to the ves object using</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1kr<span class="op">$</span>rhopar &lt;-<span class="st"> </span>res.kr.nls<span class="op">$</span>rho
sev1kr<span class="op">$</span>thickpar &lt;-<span class="st"> </span>res.kr.nls<span class="op">$</span>thickness
sev1kr<span class="op">$</span>interpreted &lt;-<span class="st"> </span><span class="ot">TRUE</span></code></pre></div>
<p>and the results are finally plotted:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p4 &lt;-<span class="st"> </span><span class="kw">plot</span>(sev1kr, <span class="dt">type =</span> <span class="st">"ves"</span>)
<span class="kw">print</span>(p4)</code></pre></div>
<p><img src="rves-smoothing_files/figure-html/plot_sevkr-1.png" width="576" style="display: block; margin: auto;"> Again the effect of the smoothing is seen in the reduction of the RMS obtained during the calibration that now reaches a values of <span class="math inline">\(0.628\)</span> (down from <span class="math inline">\(1.35\)</span>). The number of layers did no change but there are small differences in the resistivities obtained during the calibration step when compared to the results of the smoothing spline and no smoothing.</p>
</div>
<div id="wavelet-smoothing" class="section level3">
<h3 class="hasAnchor">
<a href="#wavelet-smoothing" class="anchor"></a>Wavelet Smoothing</h3>
<p>The third method for ves smoothing is wavelet thresholding which is applied in a similar manner to the previously explained methods:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.wv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/smoothing_ves.html">smoothing_ves</a></span>(sev1a, <span class="dt">method =</span> <span class="st">"wavelet"</span>)</code></pre></div>
<p>The results of the smoothing are assigned to a data.frame for visual comparison with the original values</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ab2.def &lt;-<span class="st"> </span><span class="kw">rep</span>(res.wv<span class="op">$</span>ab2, <span class="dv">2</span>)
apprho.def &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'numeric'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
apprho.def[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span>res.wv<span class="op">$</span>apprho
apprho.def[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span>sev1a<span class="op">$</span>appres
meas.type &lt;-<span class="st"> </span><span class="kw">vector</span>(<span class="st">'character'</span>, <span class="dt">length =</span> <span class="dv">36</span>)
meas.type[<span class="dv">1</span><span class="op">:</span><span class="dv">18</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"wavelet.thresholding"</span>, <span class="dv">18</span>)
meas.type[<span class="dv">19</span><span class="op">:</span><span class="dv">36</span>] &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="st">"raw"</span>, <span class="dv">18</span>)
res.wv.df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">ab2 =</span> ab2.def, <span class="dt">apprho =</span> apprho.def, 
                        <span class="dt">type =</span> <span class="kw">as.factor</span>(meas.type))</code></pre></div>
<p>and this data.frame is plotted</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p.wv &lt;-<span class="st"> </span><span class="kw">ggplot</span>() <span class="op">+</span><span class="st"> </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">x =</span> ab2, <span class="dt">y =</span> apprho, <span class="dt">color =</span> type), 
                              <span class="dt">data =</span> res.wv.df) <span class="op">+</span>
<span class="st">  </span><span class="kw">scale_x_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">scale_y_log10</span>() <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">'Comparison'</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">theme_bw</span>()
<span class="kw">print</span>(p.wv)  </code></pre></div>
<p><img src="rves-smoothing_files/figure-html/wave2-1.png" width="576" style="display: block; margin: auto;"></p>
<p>where it is clear that the smoothing modified values for all spacings. These results are used to define a new ves object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1wv &lt;-<span class="st"> </span><span class="kw"><a href="../reference/ves.html">ves</a></span>(<span class="dt">id =</span> <span class="st">"Sounding 1-Wavelet Thresholding"</span>, <span class="dt">ab2 =</span> res.wv<span class="op">$</span>ab2, 
              <span class="dt">apprho =</span> res.wv<span class="op">$</span>apprho)</code></pre></div>
<p>which in turn is used to estimate the layer parameters:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">res.wv.nls &lt;-<span class="st"> </span><span class="kw"><a href="../reference/calibrate_nls.html">calibrate_nls</a></span>(sev1wv, par0, <span class="dt">iterations =</span> <span class="dv">10</span>, <span class="dt">ireport =</span> <span class="dv">5</span>)
<span class="co">#&gt; iteration, RSS, Rel Error =  0 0.002237578 3.160632 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  5 0.000316812 1.213085 </span>
<span class="co">#&gt; iteration, RSS, Rel Error =  9 0.000125947 0.7301994</span></code></pre></div>
<p>The results of the calibration are assigned again to the ves object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sev1wv<span class="op">$</span>rhopar &lt;-<span class="st"> </span>res.wv.nls<span class="op">$</span>rho
sev1wv<span class="op">$</span>thickpar &lt;-<span class="st"> </span>res.wv.nls<span class="op">$</span>thickness
sev1wv<span class="op">$</span>interpreted &lt;-<span class="st"> </span><span class="ot">TRUE</span></code></pre></div>
<p>and finally the results are plotted.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p5 &lt;-<span class="st"> </span><span class="kw">plot</span>(sev1wv, <span class="dt">type =</span> <span class="st">"ves"</span>)
<span class="kw">print</span>(p5)</code></pre></div>
<p><img src="rves-smoothing_files/figure-html/wave6-1.png" width="576" style="display: block; margin: auto;"></p>
<p>The effect of the smoothing is seen in the reduction of the RMS to a value of <span class="math inline">\(0.602\)</span>, which is the smallest rms value obtained so far. In addition the resistivity of the third layer is less than the corresponding value estimated with the smoothing spline, kernel regression and no smoothing; whereas there is an increase in the true resistivity of the second layer. Despite these differences, the layered model did not change in a significant way.</p>
</div>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h2>
<div id="refs" class="references">
<div id="ref-Green1994">
<p>Green, PJ, and BW Silverman. 1994. <em>Nonparametric Regression and Generalized Linear Models: A Roughness Penalty Approach</em>. United Kingdom: Chapman &amp; Hall.</p>
</div>
<div id="ref-Kloke2015">
<p>Kloke, John., and Joseph W. McKean. 2015. <em>Nonparametric Statistical Methods Using R /</em>. Chapman &amp; Hall/Crc the R Series. Boca Raton, Florida : CRC Press,</p>
</div>
<div id="ref-Stanley_Raj_2016">
<p>Raj, A. Stanley, D. Hudson Oliver, Y. Srinivas, and J. Viswanath. 2016. “Wavelet Denoising Algorithm to Refine Noisy Geoelectrical Data for Versatile Inversion.” <em>Modeling Earth Systems and Environment</em> 2 (1). Springer Nature. doi:<a href="https://doi.org/10.1007/s40808-016-0091-0">10.1007/s40808-016-0091-0</a>.</p>
</div>
<div id="ref-Taswell_2000">
<p>Taswell, C. 2000. “The What, How, and Why of Wavelet Shrinkage Denoising.” <em>Computing in Science &amp; Engineering</em> 2 (3). Institute of Electrical; Electronics Engineers (IEEE): 12–19. doi:<a href="https://doi.org/10.1109/5992.841791">10.1109/5992.841791</a>.</p>
</div>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li>
<a href="#basic-concepts">Basic Concepts</a><ul class="nav nav-pills nav-stacked">
<li><a href="#smoothing-via-splines">Smoothing via splines</a></li>
      <li><a href="#smoothing-via-kernel-regression">Smoothing via Kernel Regression</a></li>
      <li><a href="#smoothing-via-wavelet-shrinkage">Smoothing via Wavelet Shrinkage</a></li>
      </ul>
</li>
      <li>
<a href="#example">Example</a><ul class="nav nav-pills nav-stacked">
<li><a href="#ves-1">VES 1</a></li>
      <li><a href="#references">References</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Oscar Garcia-Cabrejo.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://pkgdown.r-lib.org/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  

  </body>
</html>
